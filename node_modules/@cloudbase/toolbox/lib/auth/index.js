"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
const web_auth_1 = require("./web-auth");
const common_1 = require("./common");
const credential_1 = require("./credential");
const error_1 = require("../error");
__export(require("./common"));
__export(require("./credential"));
__export(require("./web-auth"));
class AuthSupevisor {
    constructor(options = {}) {
        const { cache, proxy } = options;
        this.requestConfig = {
            proxy
        };
        this.needCache = cache;
        this.cacheExpiredTime = 0;
    }
    static getInstance(options = {}) {
        if (AuthSupevisor.instance) {
            return AuthSupevisor.instance;
        }
        const instance = new AuthSupevisor(options);
        AuthSupevisor.instance = instance;
        return instance;
    }
    getLoginState() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.cacheCredential && this.needCache && !this.isCacheExpire()) {
                return this.cacheCredential;
            }
            const credential = yield credential_1.checkAndGetCredential(this.requestConfig);
            if (this.needCache && credential) {
                this.cacheCredential = credential;
                const { accessTokenExpired } = credential;
                this.cacheExpiredTime = accessTokenExpired
                    ? Number(accessTokenExpired)
                    : Date.now() + 3600 * 1000;
            }
            return credential;
        });
    }
    loginByWebAuth(options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            const { getAuthUrl, throwError } = options;
            if (this.cacheCredential && this.needCache && !this.isCacheExpire()) {
                return this.cacheCredential;
            }
            let credential = yield credential_1.checkAndGetCredential(this.requestConfig);
            if (credential)
                return credential;
            credential = yield web_auth_1.getAuthTokenFromWeb({
                getAuthUrl
            });
            try {
                yield common_1.checkAuth(credential, this.requestConfig);
            }
            catch (error) {
                if (throwError) {
                    throw error;
                }
                return null;
            }
            const webCredential = common_1.resolveWebCredential(credential);
            yield credential_1.authStore.set('credential', webCredential);
            if (this.needCache && credential) {
                this.cacheCredential = credential;
                const { accessTokenExpired } = credential;
                this.cacheExpiredTime = accessTokenExpired
                    ? Number(accessTokenExpired)
                    : Date.now() + 3600 * 1000;
            }
            return credential;
        });
    }
    loginByApiSecret(secretId, secretKey, token) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.cacheCredential && this.needCache && !this.isCacheExpire()) {
                return this.cacheCredential;
            }
            let credential = yield credential_1.checkAndGetCredential(this.requestConfig);
            if (credential)
                return credential;
            if (!secretId || !secretKey) {
                throw new error_1.CloudBaseError('secretId 或 secretKey 不能为空');
            }
            credential = {
                secretId,
                secretKey,
                token
            };
            try {
                yield common_1.checkAuth(credential, this.requestConfig);
            }
            catch (error) {
                return null;
            }
            yield credential_1.authStore.set('credential', credential);
            if (this.needCache && credential) {
                this.cacheCredential = credential;
                this.cacheExpiredTime = Date.now() + 3600 * 1000;
            }
            return credential;
        });
    }
    logout() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.cacheCredential) {
                this.cacheCredential = null;
            }
            const credentail = yield credential_1.getCredentialWithoutCheck();
            try {
                if (credentail === null || credentail === void 0 ? void 0 : credentail.refreshToken) {
                    yield credential_1.refreshTmpToken(Object.assign(Object.assign({}, credentail), { isLogout: true }));
                }
                yield credential_1.authStore.delete('credential');
            }
            catch (e) {
                yield credential_1.authStore.delete('credential');
            }
        });
    }
    isCacheExpire() {
        const now = Date.now();
        this.cacheExpiredTime = this.cacheExpiredTime || 0;
        return now >= this.cacheExpiredTime;
    }
}
exports.AuthSupevisor = AuthSupevisor;
