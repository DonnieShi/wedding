import { getAuthTokenFromWeb } from './web-auth'
import { checkAuth, resolveWebCredential } from './common'
import {
    authStore,
    refreshTmpToken,
    checkAndGetCredential,
    getCredentialWithoutCheck
} from './credential'
import { Credential } from '../types'
import { CloudBaseError } from '../error'

export * from './common'
export * from './credential'
export * from './web-auth'

export interface AuthSupevisorOptions {
    // 是否在内存中缓存 credential 信息
    cache?: boolean
    // 代理配置
    proxy?: string
}

export interface RequestConfig {
    proxy: string
}

export interface WebAuthOptions {
    //
    throwError?: boolean
    getAuthUrl?: (rawUrl: string) => string
}

export class AuthSupevisor {
    static instance: AuthSupevisor
    /**
     * 单例模式，全局缓存
     * @param options
     */
    static getInstance(options: AuthSupevisorOptions = {}) {
        if (AuthSupevisor.instance) {
            return AuthSupevisor.instance
        }
        const instance = new AuthSupevisor(options)
        AuthSupevisor.instance = instance
        return instance
    }

    // 缓存结果
    cacheCredential: Credential
    // 是否需要缓存
    needCache: boolean
    // 缓存过期时间
    cacheExpiredTime: number
    // 请求配置
    requestConfig: RequestConfig

    constructor(options: AuthSupevisorOptions = {}) {
        const { cache, proxy } = options
        this.requestConfig = {
            proxy
        }
        this.needCache = cache
        this.cacheExpiredTime = 0
    }

    /**
     * 获取登录状态信息
     */
    async getLoginState(): Promise<Credential> {
        if (this.cacheCredential && this.needCache && !this.isCacheExpire()) {
            return this.cacheCredential
        }

        // 获取本地登录状态
        const credential: Credential = await checkAndGetCredential(this.requestConfig)

        if (this.needCache && credential) {
            this.cacheCredential = credential
            const { accessTokenExpired } = credential
            this.cacheExpiredTime = accessTokenExpired
                ? Number(accessTokenExpired)
                : Date.now() + 3600 * 1000
        }

        return credential
    }

    /**
     * 通过网页授权登录
     * @returns credential
     */
    async loginByWebAuth(options: WebAuthOptions = {}): Promise<Credential> {
        const { getAuthUrl, throwError } = options

        if (this.cacheCredential && this.needCache && !this.isCacheExpire()) {
            return this.cacheCredential
        }

        // 校验本地秘钥
        let credential: Credential = await checkAndGetCredential(this.requestConfig)
        if (credential) return credential

        // 兼容临时秘钥
        credential = await getAuthTokenFromWeb({
            getAuthUrl
        })

        try {
            await checkAuth(credential, this.requestConfig)
        } catch (error) {
            if (throwError) {
                throw error
            }
            return null
        }

        // 通过 Web 登录时，本地要存储 tmpSecretId 形式，方式 CLI 登录失效
        const webCredential = resolveWebCredential(credential)
        await authStore.set('credential', webCredential)

        // 缓存处理转换后的 credential
        if (this.needCache && credential) {
            this.cacheCredential = credential
            const { accessTokenExpired } = credential

            this.cacheExpiredTime = accessTokenExpired
                ? Number(accessTokenExpired)
                : Date.now() + 3600 * 1000
        }

        return credential
    }

    /**
     * 通过 API Secret 登录，支持临时秘钥
     * @param secretId
     * @param secretKey
     * @param token
     * @returns credential
     */
    async loginByApiSecret(
        secretId?: string,
        secretKey?: string,
        token?: string
    ): Promise<Credential> {
        if (this.cacheCredential && this.needCache && !this.isCacheExpire()) {
            return this.cacheCredential
        }

        // 校验本地秘钥
        let credential: Credential = await checkAndGetCredential(this.requestConfig)
        if (credential) return credential

        // 当本地身份信息不存在时，才使用传入参数进行校验
        if (!secretId || !secretKey) {
            throw new CloudBaseError('secretId 或 secretKey 不能为空')
        }

        credential = {
            secretId,
            secretKey,
            token
        }

        try {
            await checkAuth(credential, this.requestConfig)
        } catch (error) {
            return null
        }

        // 存储信息
        await authStore.set('credential', credential)

        if (this.needCache && credential) {
            this.cacheCredential = credential
            this.cacheExpiredTime = Date.now() + 3600 * 1000
        }

        return credential
    }

    async logout() {
        if (this.cacheCredential) {
            this.cacheCredential = null
        }
        const credentail: Credential = await getCredentialWithoutCheck()

        try {
            // 仅使用 Web 控制台授权登录时才删除 token
            if (credentail?.refreshToken) {
                await refreshTmpToken({
                    ...credentail,
                    isLogout: true
                })
            }
            await authStore.delete('credential')
        } catch (e) {
            await authStore.delete('credential')
        }
    }

    private isCacheExpire(): boolean {
        const now = Date.now()
        this.cacheExpiredTime = this.cacheExpiredTime || 0
        return now >= this.cacheExpiredTime
    }
}
