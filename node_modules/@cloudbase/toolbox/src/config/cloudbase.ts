import _ from 'lodash'
import path from 'path'
import jsonfile from 'jsonfile'
import Mustache from 'mustache'
import { loadConfig } from './cosmiconfig'
import { CloudBaseError } from '../error'
import { ICloudBaseConfig } from '../types'

const DefaultCloudBaseConfig = {
    functionRoot: './functions',
    functions: []
}

export interface ResolveOptions {
    // 指定搜索路径
    searchFrom?: string
    // 指定配置文件路径
    configPath?: string
}

/**
 * 从配置文件中解析 cloudbase 配置
 */
export async function resolveCloudBaseConfig(options: ResolveOptions): Promise<ICloudBaseConfig> {
    const { configPath, searchFrom } = options

    const oldTcbConfig = await loadConfig({
        configPath,
        searchFrom,
        moduleName: 'tcb'
    })

    // 检查旧的配置文件
    if (oldTcbConfig) {
        throw new CloudBaseError('tcbrc.json 配置文件已废弃，请使用 cloudbaserc 配置文件！')
    }

    // 可能为 null
    const localCloudBaseConfig = await loadConfig({
        searchFrom,
        configPath
    })

    // localCloudBaseConfig 不为空，且不存在 envId
    if (localCloudBaseConfig && !localCloudBaseConfig.envId) {
        throw new CloudBaseError('无效的配置文件，配置文件必须包含环境 Id(envId) 字段')
    }

    const cloudbaseConfig: ICloudBaseConfig = {
        ...DefaultCloudBaseConfig,
        ...localCloudBaseConfig
    }

    // 兼容不同形式的配置
    if (cloudbaseConfig.functions?.length) {
        cloudbaseConfig.functions = cloudbaseConfig.functions?.map((func) => {
            if ((func as any).config) {
                return {
                    ...func,
                    ...(func as any).config
                }
            } else {
                return func
            }
        })
    } else {
        cloudbaseConfig.functions = []
    }

    return cloudbaseConfig
}

/**
 * 从命令行和配置文件中获取 envId
 */
export async function getEnvId(commandOptions): Promise<string> {
    const envId = commandOptions?.envId
    const configPath = commandOptions?.parent?.configFile

    const cloudbaseConfig = await resolveCloudBaseConfig(configPath)
    // 命令行 envId 可以覆盖配置文件 envId
    const assignEnvId = envId || cloudbaseConfig?.envId
    return assignEnvId
}

export interface ICloudBaseOptions {
    cwd: string
    // 是否覆盖本地同名配置，默认为为 true
    cover?: boolean
    // 指定配置路径
    configPath?: string
}

export const renderConfig = (template: string, view: Record<string, any>) =>
    Mustache.render(template, view)

// cloudbase v2+ 配置文件解析器
export class ConfigParser {
    static instance: ConfigParser

    static async get(options: ICloudBaseOptions, key?: string, defaultValue?: any) {
        if (!ConfigParser.instance) {
            ConfigParser.instance = new ConfigParser(options)
        }
        return this.instance.options(options).get(key, defaultValue)
    }

    static async update(options: ICloudBaseOptions, key?: string, value?: any) {
        if (!ConfigParser.instance) {
            ConfigParser.instance = new ConfigParser(options)
        }
        return this.instance.options(options).update(key, value)
    }

    private cwd: string
    private configPath: string
    private cover: boolean

    constructor(options: ICloudBaseOptions) {
        const { cwd, cover = true, configPath } = options
        this.cover = cover
        this.configPath = configPath
        this.cwd = cwd || process.cwd()
    }

    // get config value by lodash object paths
    // https://lodash.com/docs/4.17.15#get
    async get<T>(key?: string, defaultValue?: T) {
        const config = await this.resolveConfig()

        // 不带 key，返回整个配置
        if (!key) {
            return config
        }

        // 返回具体字段的值
        return _.get(config, key, defaultValue)
    }

    // update config value by lodash object paths
    // https://lodash.com/docs/4.17.15#set
    async update(key: string | Record<string, any>, value?: any) {
        const config = await this.resolveConfig()
        let assignConfig
        // 当 value 为 undefined 且 key 为对象时，直接把 key 作为值更新到 config 中
        if (typeof value === 'undefined' && typeof key === 'object') {
            assignConfig = {
                ...config,
                ...key
            }
        } else {
            assignConfig = _.set(config, key as string, value)
        }

        await this.writeConfig(assignConfig)
    }

    // 读配置
    async resolveConfig(searchFrom = this.cwd, configPath = this.configPath) {
        const rawConfig = await resolveCloudBaseConfig({
            searchFrom,
            configPath
        })

        let config = rawConfig

        if (config.version) {
            let configString = JSON.stringify(rawConfig)
            configString = renderConfig(configString, {})

            config = JSON.parse(configString)
        }

        return config
    }

    // 写配置
    async writeConfig(config: ICloudBaseConfig, cover = this.cover) {
        const configPath = path.join(this.cwd, '.cloudbaserc.json')
        const localCloudBaseConfig = await loadConfig({
            configPath
        })

        const newConfig = cover
            ? {
                  ...localCloudBaseConfig,
                  config
              }
            : {
                  ...config,
                  ...localCloudBaseConfig
              }

        // 写入配置到 json 文件中
        jsonfile.riteFileSync(configPath, newConfig, { spaces: 2 })
    }

    // 重写内部配置
    options(options: ICloudBaseOptions) {
        const { cwd, cover = true, configPath } = options
        this.cover = cover
        this.configPath = configPath
        this.cwd = cwd
        return this
    }
}
